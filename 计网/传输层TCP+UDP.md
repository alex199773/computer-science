------

[TOC]

------

### TCP

#### TCP简介

- 提供可靠传输，支持全双工，面向字节流
- 传送数据单元：报文段
- 首部：前20个字节固定，后4n字节可选。
  - 端口：源端口和目的端口16bit，0-1024系统保留，1024-65535用户使用。
  - 序号：4字节
  - 确认号：4字节
  - 检验和：16bit，检验首部和数据。



------

#### 三次握手

![](D:\file\Typora\三次挥手_files\1614160878-FiFlkq-image.png)

> ack是确认号，对上一个包的序号确认，ack=seq+1。
>
> ACK是标志位，ACK置1表示该数据包对上一个包进行了确认。

1. 为什么三次握手而不是二次握手？

   三次握手的主要目的是确认自己和对方的发送和接收都是正常的。

   **两次握手**：client向server发送seq=x的数据包，server收到，并确认，向client发送seq=y，ack=x+1的数据包。此时client的序号x被确认，而server的序号y没有被client接收确认。

   如果第二次传输的数据包丢失时，客户端因为超时未收到关闭连接，而重新请求。而服务器端不知道，在第二次发出数据包后就打开端口。等到客户端发出新请求，服务器端会打开新端口。这样造成服务器资源的浪费。

   **三次握手**：可以防止历史连接的建立，并且帮助双方同步初始化序列号（序列号可以保证数据包不重复，不丢弃，按需传输）。

   

2. 为什么不是四次握手？

   三次已经足够，四次浪费资源

   

------

#### 四次挥手

![](D:\file\Typora\三次挥手_files\1612459478-ajInIu-四次挥手.png)

- client向server发出第一次FIN报文后，进入半关闭阶段，client停止向server发送数据。
- client接收到server的第四次数据包后，等待2MSL，正式关闭服务器到客户端方向上的连接。

1. 为什么要四次挥手？

   如果client主动关闭，这时候server可能还有数据要发送，所以发送第二次ACK确认报文。

2. CLOSE-WAIT阶段

   服务器将剩下部分的数据发送完。

3. TIME-WAIT阶段

   客户端等待第四次数据包到达，如果2MSL内没有收到新packet，说明没有超时重传。

   MSL：报文最大生存时间。

   每个连接关闭都会有TIME-WAIT，此时维护连接需要socket，如果有许多连接，会导致正常连接失败。



------

#### 流量控制

- 滑动窗口：TCP首部字段【接收窗口】，接收方使用该字段通知发送方自己还有多少缓存区。
- 



------

#### 拥塞控制

> 滑动窗口只考虑了接收方的处理能力，没考虑网络的通畅问题，比如：服务端可以处理100M数据，但是传输的数据99M都堵在路上了，这不就是导致道路阻塞了么？这就需要另外一个设计**「拥塞避免」**



> rwnd：接收窗口，接收方通知发送方来调整发送速率。
>
> cwnd：拥塞窗口，发送方探查网络（通过接收ACK状态）来调整。



```
每个传输轮次的时间为往返RTT
初始化：cwnd=1（报文段的大小）， ssthresh=S
```



| 算法           |                                                              | cwnd、ssthresh                                               |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 慢启动         | 每个传输轮次cwnd加倍                                         | cwnd=1、2、4······，当cwnd>ssthresh时执行拥塞避免            |
| 拥塞避免       | 每个传输轮次cwnd+1                                           | 在慢启动和拥塞避免阶段，如果出现超时，ssthresh=1/2ssthresh, cwnd=1 |
| 快重传、快恢复 | 接收方每收到一次时序报文，发送重复确认，如果发送方连续收到三次重复确认，进入快重传阶段，立即重传未收到的报文段。 | ssthresh=1/2ssthresh，cwnd=当前ssthresh，进入拥塞避免阶段。cwnd缓慢增加 |



------

#### DOS和DDOS攻击

**DOS攻击**：【Denial Of Service 拒绝服务】，单机和单机之间的攻击

原理：攻击者发送被攻击方服务器大量的虚假IP请求，由于攻击者发送的请求信息是虚假的，所以服务器接收不到返回的确认信息，在一段时间内服务器会处与等待状态，而分配给这次请求的资源却被有被释放.当被攻击者等待一定的时间后，会因连接超时而断开，这时攻击者在次发送新的虚假信息请求，这样最终服务器资源被耗尽，直到瘫痪。严重阻止服务器响应外来的合法请求。

**DDOS攻击**：【Distributed Denial Of Service 分布式拒绝服务】，在DOS攻击的基础上大范围的攻击模式，DDOS在互联网寻找一些有漏洞的主机入侵，利用这些受控制的僵尸主机向一台服务器发起攻击。更具破坏性。而且在幕后操控，很难被跟踪。

常见DOS攻击方式：

1. SYN Flood攻击

   攻击者在短时间内伪造大量不存在的IP地址，向目标服务器发送SYN数据包（TCP三次握手第一阶段），迫使服务器回复大量SYN+ACK确认包，并等待ACK确认（第三阶段）。由于这些IP不存在，所以服务器无法得到回应以致超时，服务器不断重发。这些得不到确认的SYN包将长期占用队列，使得正常的请求被丢弃或拒绝。导致目标系统运行缓慢，严重者会引起网络堵塞甚至目标系统底层操作系统瘫痪。

   > 解决方法：
   >
   > 1. 缩短SYN数据包超时时间，使得无效SYN包不会长期占据队列。
   > 2. 增加SYN队列大小，可以容纳更多SYN包。
   > 3. 源地址验证，如果是伪造的就丢弃SYN包。
   > 4. 丢弃第一次SYN包，正常IP会发送第二次，而虚假IP不会。
   > 5. 开启SYN Cookies，给每个请求的IP分配一个Cookie，当收到相同SYN的数据包时，服用之前的ACK号。











------

### UDP

UDP首部：源端口(2字节)+目的端口(2字节)+长度(2字节)+检验和(2字节)

#### TCP和UDP对比

|          | TCP                            | UDP                    |
| -------- | ------------------------------ | ---------------------- |
| 连接性   | 面向连接                       | 无连接                 |
| 可靠性   | 可靠                           | 不可靠                 |
| 传输单位 | 面向字节                       | 面向报文（不拆分）     |
|          | 一对一                         | 一对一、一对多、多对多 |
| 首部     | >=20字节                       | 8字节                  |
| 传输速度 | 慢                             | 快                     |
|          | 流量控制、拥塞控制             | 无                     |
| 协议     | HTTP、HTTPS、FTP、SMTP、TELNET | DNS、RIP、DHCP、TFTP   |

