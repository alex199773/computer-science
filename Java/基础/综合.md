----

[TOC]

----

#### java语言和Python、C++、C对比

|              | Java     | Python       | C++            | C            |
| ------------ | -------- | ------------ | -------------- | ------------ |
| 类型         | 面向对象 | 面向对象     | 面向对象       | 面向过程     |
| 垃圾回收机制 | 有       | 有           | 手动           | 手动         |
| 指针         | 无       | 无           | 有             | 有           |
| 适用场景     | 大型项目 | 快速开发项目 | 需求效率高项目 | 系统开发项目 |
| 运行速度     | 慢       | 慢           | 快             | 快           |



#### 面向对象 特性

##### 封装



##### 继承



##### 多态



#### HashCode作用

java的集合有两类，一类是List，还有一类是Set。前者有序可重复，后者无序不重复。当我们在set中插入的时候怎么判断是否已经存在该元素呢，可以通过equals方法。但是如果元素太多，用这样的方法就会比较慢。（一个个比较）

于是有人发明了哈希算法来提高集合中查找元素的效率。 这种方式将集合分成若干个存储区域，每个对象可以计算出一个哈希码，可以将哈希码分组，每组分别对应某个存储区域，根据一个对象的哈希码就可以确定该对象应该存储的那个区域。**（一个哈希码对应一块空间，一块空间可以存放多个对象）**

hashCode方法可以这样理解：它返回的就是根据对象的内存地址换算出的一个值。这样一来，当集合要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。**（添加新元素到set时，先找到hashcode对应的地址空间，如果没有元素，则可插入，如果该空间有元素，再使用equals方法和元素对比）**
