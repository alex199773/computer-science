----

[TOC]

----

### 进程

#### 进程状态[^1]

**【运行】、【阻塞】、【就绪】**

【僵尸进程[^1]】

- 已完成且终止，但进程状态信息仍然存在于进程表中。
- 原因：父进程没有调用回收。
- 影响：占用系统资源
- 解决：父进程回收子进程状态信息



【孤儿进程】

- 父进程退出，子进程还在运行。
- init进程会收留孤儿进程。不会对系统造成危害。



#### 调度算法[^1]

| 调度算法         | 具体                                                         | 优点       | 缺点                                                     |
| ---------------- | ------------------------------------------------------------ | ---------- | -------------------------------------------------------- |
| 先来先服务FCFS   | 非抢占式                                                     | 利于长作业 | 不利于短作业，不利于IO密集型进程（每次IO后需要重新排队） |
| 短作业优先SJF    | 非抢占式                                                     | 利于短作业 | 长作业可能会饿死                                         |
| 优先级调度       | 分配优先级，可以随着时间推移增加优先级                       |            |                                                          |
| 时间片轮转       | 先来先排列，每次分一个时间片，用完送往队尾                   |            | 时间片过长：相当于先来先服务；时间片过短：频繁切换花时间 |
| 高响应比优先     | 非抢占式，每次选择响应比最高的，相应比=（等待时间+处理时间）/处理时间 |            |                                                          |
| 多级反馈队列     | 多个队列，优先级不同。优先级越高时间片越短。优先调度优先级高的队列，时间片用完分到下一个队列。 |            |                                                          |
| 最短剩余时间优先 | 最短作业优先的抢占式版本                                     |            |                                                          |



#### 进程间通信[^2]

##### 共享内存

多个进程共享一块地址空间，某个进程写入的东西，其他进程可以看到。需要搭配信号量等来实现同步和互斥。



##### 消息队列

数据分为一个个消息体，放入消息队列中，先进先出。可以双向传输。

一个向队列中写，一个从队列中读。



##### 管道

管道传输是==单向==的，相互通信需要两个管道。

匿名管道：只用于父子进程之间的通信

命名管道：不相关进程之间

管道：即内核中的一串缓存，从管道一端写入，即将内容写入缓存，另一方读取数据，即从内核缓存中取。



##### 信号量

信号量是个整型计数器，用于同步和互斥，没有缓存通信的数据。

控制信号量操作：

- P（信号量-1），在进入共享资源之前
- V（信号量+1），离开共享资源之后

##### 信号

信号是进程间通信机制中**唯一的异步通信机制**，因为可以在任何时候发送信号给某一进程。



##### Socket

以上都是同一主机上的进程通信，Socket是跨主机通信。



#### 进程、线程、协程

协程，是一个特殊的函数、轻量级线程。这个函数可以在某个地方挂起，在挂起处运行



#### 程序内存空间[^5][^7]

对于32位的操作系统 ，寻址空间有4G，即一个进程最大空间为4G。操作系统将4G华为内核空间（高位1G)和用户空间（低位3G），用户空间分为：代码段、数据段、堆、栈、BSS。

现有两个程序，编译后是虚拟地址，需要加载到物理空间中

以java程序为例：

java程序运行在虚拟机上，JVM运行程序时会把内存空间分为

- 线程共享区：方法区、堆
- 线程隔离区：程序计数器、虚拟机栈、本地方法栈

##### 堆

- 一种数据结构
- 存放对象实例（new 创建的），java通过垃圾机制收取
- 堆一般比栈大，但是读取速度较慢

##### 栈=堆栈

- 为线程分配的
- 特点：先进后出，所以方便来保，堆空间存、恢复现场
- 存放临时创建的局部变量、函数的返回地址，参数。

##### 其他

- 全局变量、静态变量、常量存储在静态存储区

### 线程

==进程是资源分配的基本单位，线程是CPU调度的最小单位。==

**线程的引入**：解决高并发问题，进程切换开销大。

**线程的组成**：

1. 线程ID 

2. 寄存器、堆栈

3. 当前指令PC

   

![img](https://images2015.cnblogs.com/blog/1048430/201707/1048430-20170710134630947-1108860021.png)



#### 进程和线程区别

**拥有资源的区别**：

- 进程有完整资源，线程共同使用进程的资源（内存空间）。
- 线程独享寄存器、栈等资源。

**线程相比于进程的优势**[^3]：

- 进程切换：切换PCB、内核态堆栈、页表，cache（虚拟地址和物理地址转换）。涉及进程虚拟地址空间的转换，线程不需
- 线程切换：不需要切换页表。只需要切换线程私有数据。

- 线程切换的开销，显著小于进程切换的开销



#### 线程间同步

*临界区*：共享资源访问的程序片断。访问时互斥。

**【锁】**：访问时加锁，访问完解锁

**【信号量】**：进入临界区前P，离开之后V



#### 多进程、多线程

函数执行就是一个线程，main函数是主线程。线程上下文 Thread context=（栈区，PC、栈指针、寄存器）。

##### Python[^6]

多进程：

```python
# 多进程包
import multiprocessing

ml = multiprocessing.Process(target = 任务名)
ml.start()
```

多线程：

```python
import threading

th = threading.Thread(target = 任务名)
th.start()

# example:
def dance():
    for _ in range(3):
        print("跳舞")
        time.sleep(1)


def sing():
    for _ in range(3):
        print("唱歌")
        time.sleep(1)


if __name__ == '__main__':
    t1 = threading.Thread(target=dance)
    t2 = threading.Thread(target=sing)
    t1.start()
    t2.start()
```



### 死锁[^4]

死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

#### 死锁必要条件

1. 互斥
2. 请求和持有
3. 不可剥夺
4. 循环等待：若干进程之间形成一种头尾相接的循环等待资源关系;



#### 死锁预防

破坏四个条件

1. 消除互斥：难实现
2. 消除请求和持有：要求一次请求所有资源（易于实现，但资源浪费且进程延迟运行）
3. 消除不可剥夺：要求资源申请不到时，主动释放拥有资源（实现复杂，反复请求释放会增加时延）
4. 消除循环等待：按序申请资源（给每种资源编号，进程按序请求资源，如现有进程甲、乙和资源4A、5B，甲需要2A3B，乙需要3A4B，给甲分配了1A，必须再分配1A才能请求B，这样不存在环路等待？）

PS：会严重损害性能



#### 死锁避免

**【银行家算法】**：当进程请求资源时，假设同意，系统会不会仍旧处于安全状态。



#### 死锁解除

1. 剥夺资源：直接剥夺其他进程的资源给死锁进程
2. 撤销死锁进程或其他进程留出资源。



#### 死锁检测

根据**【资源分配图、死锁定理】**来判断

### Ref

[^1]:[操作系统常见面试题 - 掘金 (juejin.cn)](https://juejin.cn/post/7014301927408140296)
[^2]:[ 六种进程间通信方式_modi000的博客-CSDN博客_进程间通信](https://blog.csdn.net/modi000/article/details/122084165)
[^3]:[进程/线程上下文切换会用掉你多少CPU？ - 简书 (jianshu.com)](https://www.jianshu.com/p/ebf1f832694c)
[^4]:[预防死锁的方法以及死锁的检测与解除_loveCC_orange的博客-CSDN博客_预防死锁的方法](https://blog.csdn.net/loveCC_orange/article/details/123156362)
[^5]:[干货 | 进程、线程、协程 10 张图讲明白了！ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/337978321)
[^6]:[Python多进程与多线程_阿朱__的博客-CSDN博客_python多进程多线程](https://blog.csdn.net/qq_41371858/article/details/122338599)
[^7]:[线程与进程，你真的清楚吗？ (baidu.com)](https://baijiahao.baidu.com/s?id=1687308494061329777&wfr=spider&for=pc)